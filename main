#!/bin/sh

# cd ~/.aliases
# git pull --rebase
# git diff
# git log -p | less
# git add .
# git status
# git commit -m "comment"
# git push



# ................................   GIT    ................................ 


alias pull='echo "\n--- GIT ZSH ---" && cd ~/.aliases && git pull --rebase && cd && echo "\n--- YANDEX DISK ---" && yandex-disk status'
alias push='cd ~/.aliases; git diff; read; git add .; git commit -m "comment"; git push; cd'
# нажать q, потом enter
# read -p "Продолжить? (Y/N): " confirm && [[ $confirm == [yY] || $confirm == [yY][eE][sS] ]] || exit 1;




#  ................................   SSH    ................................ 


alias mount_inet='sshfs inet: ~/remote/inet'
alias mount_drweb='sshfs drweb: ~/remote/drweb'


# ................................   КРИПТО ПРО   ................................   


alias cdkey='cd /var/opt/cprocsp/keys/cs; ls'

cpkey () {
	folderkey=$1;  # короткое имя ; исходный каталог - каталог нахождения копируемого
	if [[ -d $folderkey ]]; 
	then	
		cp -r $folderkey /var/opt/cprocsp/keys/cs;
		cd /var/opt/cprocsp/keys/cs;
		chown -R cs:cs $folderkey;
		chmod 700 $folderkey;
		chmod 600 $folderkey/*;
		ls -lah;
		ls -lah $folderkey;
	else
		echo folderkey не задан или не существует;
	fi }



# ................................   СИСТЕМА   ................................ 

jl_data() { journalctl --since "$1" }  # format "2012-10-30 18:17:16", можно дату без времени
cash_cl() { sudo sync && sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches' }  # может зависнуть - sync наверняка не может сбросить данные кеша на носитель
alias sp='systemctl suspend'
alias rt='systemctl reboot'
alias eps='epson-printer-utility'  # утилита, показывающая уровень чернил и пр.


# ................................ files 

mkdir_gen () {
	for i in $(seq -w 1 15); do
		mkdir "$i"
		echo "Created directory: $i"
	done
}

# ................................ path to clipboard

alias ptoc='pwd | wl-copy'


# ................................ Flatpak

alias listfpak='flatpak list --app'


# ................................ dnf

alias ups='sudo dnf update'                    
alias ill='sudo dnf install'
rmv () { sudo dnf remove $1 && sudo dnf autoremove }
alias ilist='dnf list --installed | grep'
alias rlist='sudo dnf repolist'


# ................................ app others

alias vi='nvim'


# ................................ systemd

alias srvst='sudo systemctl start backup_joplin.service'
alias drd='sudo systemctl daemon-reload'
alias srvss='systemctl status backup_joplin.service'


# ................................ user group

alias csg='cat /etc/group | grep cs'  # в каких группах состоит пользователь cs


# ................................ корзина

alias rmm='trash-put $1'
alias tordel='trash-put ~/download/*.torrent'


# ................................ rename

trname () { echo $1 | tr ' ' '_' | wl-copy }

alias name='rename -av " " "_" * ; rename -av "__" "_" *'

# к имени каталога добавляет точку
# испз только для переименования файлов, потому как если и каталогов то файлы уже не найдет, т.к. каталог переименован будет
rname () {
	# Директория для поиска (по умолчанию текущая) - функция принимает её в качестве внешнего аргумента
	SEARCH_DIR=${1:-.}

	# Обработка всех файлов в директории
	find "$SEARCH_DIR" -type f | while read -r FILE; do
	    # Извлекаем директорию, имя файла и расширение
	    DIRNAME=$(dirname "$FILE")
	    BASENAME=$(basename "$FILE")
	    EXTENSION="${BASENAME##*.}"       # Расширение файла
	    FILENAME="${BASENAME%.*}"         # Имя файла без расширения

	    # Если файл без расширения, обрабатываем как есть
	    if [[ "$FILENAME" == "$BASENAME" ]]; then
	        NEW_FILENAME=$(echo "$FILENAME" | sed -e 's/[^[:alpha:]^[:digit:]-]/_/g' | sed -e 's/__/_/g')
	        NEW_BASENAME="$NEW_FILENAME"
	    else
	        # Заменяем символы в имени файла, сохраняя расширение
	        NEW_FILENAME=$(echo "$FILENAME" | sed -e 's/[^[:alpha:]^[:digit:]-]/_/g' | sed -e 's/__/_/g')
	        NEW_BASENAME="$NEW_FILENAME.$EXTENSION"
	    fi

	    # Если имя изменилось, переименовываем
	    if [ "$BASENAME" != "$NEW_BASENAME" ]; then
	        mv "$FILE" "$DIRNAME/$NEW_BASENAME"
	        echo "Renamed: $FILE -> $DIRNAME/$NEW_BASENAME"
	    fi
	done
}


rname_find () {
	# Директория для поиска (по умолчанию текущая)
	SEARCH_DIR=${1:-.}

	# Поиск файлов с "[skl]" в имени и переименование
	find "$SEARCH_DIR" -type f -name '*[skladchik.org]*' | while read -r FILE; do
		# Новое имя файла
		NEW_NAME=$(echo "$FILE" | sed 's/\[skladchik.org\] //g')
    
    		# Переименование файла
    		mv "$FILE" "$NEW_NAME"
    		echo "Renamed: $FILE -> $NEW_NAME"
	done
}


# ................................ config

alias al='alias | bat'
alias all='bat ~/.aliases/main'
alias ala='bat ~/.aliases/arc'
alias alv='bat ~/.aliases/vs'
alias alled='nvim ~/.aliases/main' 
alias alaed='nvim ~/.aliases/arc' 
alias alved='nvim ~/.aliases/vs' 
alias alssh='bat ~/.ssh/config' # псевдонимы для ssh подключений
alias alp='alias -p'
alias src='source ~/.zshrc'


# ................................ Size

# вычисляет и выводит размеры файлов и каталогов в рабочей директории
alias dfsys='btrfs filesystem df /'   # для btrfs на системном
alias ussys='sudo btrfs filesystem usage /'  # подробнее, но от рута запускать надо

# Пользоваться ncdu
alias duone='du -sch * | sort -h'  # размер каталогов первого уровня
# wildcard то работает то нет : alias duone='du -sch .[!.]* * |sort -h'
alias duhome='du -sh /home'  # размер домашнего каталога в Гб; если добавить -m или -k - в Мб или Кб
alias dusort='du -d 1 -h | sort -h'  # сортировка по размеру каталогов
# отфильтровать маленькие файлы, остальные сортировать по размеру; +G - в выводе тяжелее 1 Гб
alias dusortf='du -h /home | grep "^\s*[0-9\.]\+M" | sort -rn' 

# ................................ man yandex-disk : stop, start, publish, unpublish

alias yk='yandex-disk status'
alias ykr='yandex-disk stop && yandex-disk start'


# ................................ ls

alias l='ls -CF'
alias ll='ls -l'
alias la='ls -a'
alias lah='ls -lah'


# ................................ history

alias h='history' # в zsh команда history выводит по-умолчанию 20 последних (history 20)
alias hg='history 0 | grep $1'



# ................................   PYTHON   ................................ 


alias py='python3'
# pip --version; ups; pip list; обновить пакет $1
alias pipup='pip install --user -U $1'


# ................................ job

alias cdoleg='cd /run/user/1000/gvfs/smb-share:server=172.18.18.3,share=share/Distribu/_Upload_/Oleg'


# ................................   NET   ................................ 


alias whis='curl cli.fyi/$1' # whis -> whois - сервис - см. закладка на github

alias sited='wget --mirror -p --convert-links -P . $1'
    # wget --mirror -p --convert-links -P /home/dan xyz.com
    # -p загрузка всех файлов, необходимых для отображения страниц
    # --convert-links: ссылки будут преобразованы для локального просмотра сайта
    # -P /home/dan: материалы будут сохранены в папку /home/dan

alias flush='sudo systemd-resolve --flush-caches'



# ................................   КОНВЕРТАЦИИ   ................................ 


# список исходных кодировок iconv -l, в команде работает tab, чтобы не опечататься
# узнать кондировку - file file.txt или file -i file.txt ; второе почему-то не распознало ASCII
alias wintoutf='iconv -f WINDOWS-1251 -t UTF-8 -o $1 $2'   # $1 - out file, $2 - input file

# перекодировка имён файлов
alias fnametoutf='for file in *; do mv "$file" "`echo $file | iconv -f WINDOWS-1251 -t UTF-8`"; done'

alias mdtoepub='pandoc -f markdown -t epub nerd_.txt -o nerd.epub'

# ................................   BACKUP   ................................ 


# ................................ sync

alias apph_do='restic -r /mnt/data/y-dk/dbs/bkp/apph --password-file ~/sys/script/app-repo.pwd'
alias appj_do='restic -r /mnt/data/y-dk/dbs/bkp/appj --password-file ~/sys/script/app-repo.pwd'

alias apph_log='less +G /mnt/data/y-dk/dbs/bkp/apph.log'
alias appj_log='less +G /mnt/data/y-dk/dbs/bkp/appj.log'

sync_to_apph() {
    restic -r /mnt/data/y-dk/dbs/bkp/appj --password-file ~/sys/script/app-repo.pwd restore latest:/home/cs/app/app_data --exclude-file ~/sys/script/app-exclude.lst --delete --target /home/cs/app/app_data
}

sync_to_appj() {
    restic -r /mnt/data/y-dk/dbs/bkp/apph --password-file ~/sys/script/app-repo.pwd restore latest:/home/cs/app/app_data --exclude-file ~/sys/script/app-exclude.lst --delete --target /home/cs/app/app_data
}


# ................................ home

bp_torrent=/mnt/ext2Tb/bp_torrent
bp_data=/mnt/ext2Tb/bp_data

alias restic_data='restic -r $bp_data/data_repo --password-file ~/sys/script/app-repo.pwd --verbose backup --files-from $bp_data/list_bp.txt --exclude-caches --exclude-file $bp_data/excludes.txt'
alias rsync_torrent='rsync -avh --delete-after --log-file=$bp_torrent/rsync.log --exclude-from=$bp_torrent/excludes.txt /mnt/torrent $bp_torrent'
alias rsync_vmh='rsync -avh --delete-after --log-file=/mnt/ext2Tb/bp_vm/rsync.log /mnt/vm/gnome-boxes /mnt/vm/vbox /mnt/ext2Tb/bp_vm'

# snapshots, unlock, check, prune, mount ~/restic, forget id_snap, forget --keep-last 5 --prune
alias restic_data_do='restic -r $bp_data/data_repo --password-file ~/sys/script/app-repo.pwd'
alias restic_data_forget='restic -r /$bp_data/data_repo --password-file ~/sys/script/app-repo.pwd forget --keep-last 20 --prune'


# ................................ job

# bp_job=/run/media/cs/orico-256/bp

bp_job=/mnt/data/y-dk/dbs/bkp/job

restic_job() {
   yandex-disk stop
   restic -r $bp_job --password-file ~/sys/script/app-repo.pwd --verbose backup --files-from $bp_job/list_bp.txt --exclude-caches --exclude-file $bp_job/excludes.txt
   yandex-disk start
}

# добавить /home/cs/.config/libvirt - сохранённые состояния машин
#   ???   alias rsync_vmj='rsync -avzh --delete-after /mnt/vm/gnome-boxes ...../vm'

# snapshots, unlock, check, prune, mount ~/sys/restic, forget id_snap, forget --keep-last 5 --prune
alias restic_job_do='restic -r $bp_job --password-file ~/sys/script/app-repo.pwd'
alias restic_job_forget='restic -r $bp_job --password-file ~/sys/script/app-repo.pwd forget --keep-last 20 --prune'



# ................................   TLDR   ................................

tldr_my() { sed -n "/$1/,/$1_end/p" ~/app/app_data/Obsidian/Linux/tldr.md }
